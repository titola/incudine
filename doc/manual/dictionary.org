* The Incudine dictionary
** Condition
::: incudine-error
::: incudine-simple-error
::: incudine-compile-error
::: incudine-memory-fault-error
::: incudine-storage-condition
::: incudine-network-error
::: incudine-node-error
::: incudine-missing-arg
::: incudine-unknown-time-unit
::: incudine:incudine-undefined-vug
::: incudine:incudine-undefined-ugen
::: incudine:incudine-undefined-dsp
::: midifile:midifile-error
::: midifile:midifile-parse-error
::: midifile:invalid-variable-length-quantity
::: midifile:invalid-running-status
::: midifile:invalid-track-chunk-length
::: soundfile:soundfile-error
::: ana:analysis-file-error
::: vug:foreign-plugin-error
#+texinfo: @page
** Bus
::: bus

#+texinfo: @noindent
The utility ~bus~ is similar to ~smp-ref~ with a pre-allocated foreign
array of type ~sample~:

#+begin_example
(bus 123)
(setf (bus 123) value)
#+end_example

#+texinfo: @noindent
is equivalent to

#+begin_example
(smp-ref preallocated-foreign-array 123)
(setf (smp-ref preallocated-foreign-array 123) (sample value))
#+end_example

#+texinfo: @noindent
Example:

#+begin_example
(in-package :scratch)

(dsp! master ()
  ;; Stereo output from the first two buses.
  (out (bus 0) (bus 1))
  ;; Zero before the next audio cycle.
  (setf (bus 0) 0)
  (setf (bus 1) 0))

(dsp! track (freq amp pos)
  (foreach-channel
    ;; We can use CURRENT-CHANNEL here because MASTER reads the buses
    ;; 0 and 1, and CURRENT-CHANNEL starts from 0. INCF means "mix"
    ;; (use SETF if you want to overwrite the current bus value).
    (incf (bus current-channel) (pan2 (sine freq amp) pos))))

(dsp! stereo-test (freq amp (nbus fixnum))
  ;; The adjacent bus number is explicitally computed.
  ;; Note: this initialization avoids a sum during the performance
  ;; and it is necessary because BUS is a function.
  (with ((nbus2 (+ nbus 1)))
    (incf (bus nbus) (sine freq amp))
    ;; Note: SINE is a VUG, therefore the initialization for `(* freq 3/2)'
    ;; is implicit (there is a hidden WITH).
    (incf (bus nbus2) (sine (* freq 3/2) amp))))

(set-rt-block-size 1)
(rt-start)

(master :id 1)
;; In this case `:before 1' is unnecessary because the new node is
;; added at the head of the root node by default.
(track 440 .1 .3 :before 1)
(track 660 .15 .9 :before 1)
(stereo-test 220 .1 0 :before 1)

(free 0)
#+end_example

#+texinfo: @noindent
If the block size is greater than 1, it is necessary to change
the strategy. The following example is a possible implementation
but we can also define other utilities for custom structures
(i.e. a matrix frames*channels):

#+begin_example
(dsp! master ()
  (with ((frames (block-size)))
    (foreach-frame
      ;; Stereo output from the first blocksize*2 buses.
      (out (bus current-frame) (bus (+ frames current-frame)))
      (setf (bus current-frame) 0)
      (setf (bus (+ frames current-frame)) 0))))

(dsp! track (freq amp pos)
  (with ((frames (block-size)))
    (foreach-frame
      (foreach-channel
        (incf (bus (+ current-frame
                      (the fixnum (* frames current-channel))))
              (pan2 (sine freq amp) pos))))))

(dsp! stereo-test (freq amp (nbus fixnum))
  (with ((frames (+ nbus (block-size))))
    (declare (fixnum frames))
    (foreach-frame
      (incf (bus (+ nbus current-frame)) (sine freq amp))
      (incf (bus (+ frames current-frame)) (sine (* freq 3/2) amp)))))

(set-rt-block-size 64)
(rt-start)

(master :id 1)
(track 440 .1 .3)
(track 660 .15 .9)
(stereo-test 220 .1 0)

(free 0)
(set-rt-block-size 1)
#+end_example

::: audio-in
::: audio-out
::: peak-info
::: print-peak-info
::: reset-peak-meters
::: set-number-of-channels
#+texinfo: @page
** Buffer
::: buffer
::: *sine-table*
::: *cosine-table*
::: make-buffer
::: copy-buffer
::: buffer-p

#+attr_texinfo: :options {Method} free buffer
#+begin_deffn
Deallocate the ~buffer~.
#+end_deffn

#+attr_texinfo: :options {Method} free-p buffer
#+begin_deffn
Return ~t~ if the ~buffer~ is deallocated.
#+end_deffn

::: buffer-data
::: buffer-size
::: buffer-frames
::: buffer-channels
::: buffer-sample-rate
::: buffer-file
::: buffer-mask
::: buffer-lobits
::: buffer-lodiv
::: buffer-lomask

#+texinfo: @noindent
Example: wavetable lookup oscillator with phase of type integer
between 0 and ~+table-maxlen+~. Buffer size is assumed to be a
power of two.

#+texinfo: @noindent
The following DSP

#+begin_example
(dsp! oscillator-test ((buf buffer) freq amp)
  (out (osc buf freq amp 0 :linear)))
#+end_example

#+texinfo: @noindent
is equivalent to

#+begin_example
(dsp! oscillator-test ((buf buffer) freq amp)
  (with ((frac (sample 0))
         (phase 0)
         ;; Memo: *CPS2INC* is table_maxlen/sample_rate
         (phase-increment (sample->fixnum (* freq *cps2inc*)))
         (minus-lobits (- (buffer-lobits buf)))
         (index 0))
    (declare (type sample frac)
             (type fixnum phase phase-increment index)
             (type (integer #.(- +max-lobits+) 0) minus-lobits))
    (setf frac (* (buffer-lodiv buf) (logand phase (buffer-lomask buf))))
    (setf index (ash phase minus-lobits))
    (out (* amp (linear-interp frac
                  (buffer-value buf index)
                  (buffer-value buf (logand (the fixnum (1+ index))
                                            (buffer-mask buf))))))
    ;; Phase increment without branching.
    (setf phase (logand (the fixnum (+ phase phase-increment))
                        +phase-mask+))))

;; Buffer size 8192 = 2^13
(defvar *waveform* (make-buffer 8192 :fill-function (gen:partials '(1))))

(rt-start)

(oscillator-test *waveform* 440 .3)
#+end_example

::: buffer-value
::: buffer-load
::: buffer-save
::: map-buffer
::: map-into-buffer
::: resize-buffer
::: scale-buffer
::: normalize-buffer
::: rescale-buffer
::: sort-buffer

#+attr_texinfo: :options {Method} circular-shift buffer n
#+begin_deffn
Perform a circular shift of length ~n~.
#+end_deffn

#+attr_texinfo: :options {Method} quantize buffer from @andkey{} start end filter-function
#+begin_deffn
Quantize ~buffer~ with respect to a real number, a vector, a ~buffer~
or ~tuning~ structure in sorted order.

The keywords ~start~ and ~end~ are the bounding index designators, and
the keyword ~filter-function~ is usable to apply a function to the
quantized value. The arguments of that function are the vector index
and the quantized value.
#+end_deffn

::: buffer->array
::: buffer->list
::: fill-buffer
::: with-buffer
::: with-buffers
#+texinfo: @page
** Tuning
::: tuning
::: *default-tuning*
::: make-tuning
::: copy-tuning

#+attr_texinfo: :options {Method} free tuning
#+begin_deffn
Deallocate the ~tuning~.
#+end_deffn

#+attr_texinfo: :options {Method} free-p tuning
#+begin_deffn
Return ~t~ if the ~tuning~ is deallocated.
#+end_deffn

::: tuning-description
::: tuning-cents
::: tuning-ratios
::: tuning-cps
::: tuning-data
::: tuning-degree-index
::: tuning-freq-base
::: tuning-keynum-base
::: set-tuning
::: set-tuning-reference
::: set-tuning-from-midi
::: minimize-tuning-ratios
::: tuning-notes-from-data
::: tuning-save
::: load-sclfile
::: cps->pch
::: pch->cps
::: keynum->pch
::: pch->keynum

#+attr_texinfo: :options {Method} quantize tuning from @andkey{} start end filter-function
#+begin_deffn
Quantize ~tuning~ with respect to a real number, a vector, a ~buffer~
or ~tuning~ structure in sorted order.

The keywords ~start~ and ~end~ are the bounding index designators, and
the keyword ~filter-function~ is usable to apply a function to the
quantized value. The arguments of that function are the vector index
and the quantized value.
#+end_deffn

#+texinfo: @page
** Envelope
::: envelope
::: make-envelope
::: copy-envelope
::: envelope-p

#+attr_texinfo: :options {Method} free envelope
#+begin_deffn
Deallocate the ~envelope~.
#+end_deffn

#+attr_texinfo: :options {Method} free-p envelope
#+begin_deffn
Return ~t~ if the ~envelope~ is deallocated.
#+end_deffn

::: envelope-data
::: envelope-duration
::: envelope-points
::: envelope-loop-node
::: envelope-release-node
::: envelope-restart-level
::: envelope-base->curves
::: edit-envelope
::: envelope-level
::: envelope-time
::: envelope-curve
::: set-envelope-base
::: envelope-at
::: scale-envelope
::: normalize-envelope
::: rescale-envelope
::: breakpoints->env
::: freq-breakpoints->env
::: make-linen
::: make-perc
::: make-cutoff
::: make-asr
::: make-adsr
::: make-dadsr
#+texinfo: @page
** Time
::: tempo
::: make-tempo
::: tempo-p
::: *tempo*
::: bpm
::: bps
::: spb
::: tempo-envelope
::: make-tempo-envelope
::: tempo-envelope-p
::: copy-tempo-envelope

#+attr_texinfo: :options {Method} free obj
#+begin_deffn
Deallocate the ~tempo~ or ~tempo-envelope~ instance.
#+end_deffn

#+attr_texinfo: :options {Method} free-p obj
#+begin_deffn
Return ~t~ if the ~tempo~ or ~tempo-envelope~ instance is deallocated.
#+end_deffn

::: set-tempo-envelope
::: tempo-breakpoints
::: bpm-at
::: bps-at
::: spb-at
::: beats->seconds
::: seconds->beats
::: now
::: with-local-time
::: tempo-sync
::: timestamp
::: enable-sharp-square-bracket-syntax
#+texinfo: @page
** Foreign Array
::: incudine.util:with-foreign-array
::: incudine.util:with-samples
::: incudine.util:with-samples*
::: incudine.util:i8-ref
::: incudine.util:i16-ref
::: incudine.util:i32-ref
::: incudine.util:i64-ref
::: incudine.util:u8-ref
::: incudine.util:u16-ref
::: incudine.util:u32-ref
::: incudine.util:u64-ref
::: incudine.util:f32-ref
::: incudine.util:f64-ref
::: incudine.util:ptr-ref
::: incudine.external:foreign-set
::: incudine.external:foreign-copy
::: incudine.external:foreign-copy-samples
::: incudine.external:foreign-zero-sample
#+texinfo: @page
** Memory Management
::: free
::: free-p
*** Foreign Memory
::: incudine.external:foreign-alloc-sample
::: incudine.util:foreign-realloc
::: incudine.util:get-nrt-memory-max-size
::: incudine.util:get-nrt-memory-free-size
::: incudine.util:get-nrt-memory-used-size
**** Allocation in Realtime Thread
::: incudine.util:*allow-rt-memory-pool-p*
::: incudine.util:allow-rt-memory-p
::: incudine.util:foreign-rt-alloc
::: incudine.util:foreign-rt-realloc
::: incudine.util:foreign-rt-free
::: incudine.util:safe-foreign-rt-free
::: incudine.util:get-rt-memory-max-size
::: incudine.util:get-rt-memory-free-size
::: incudine.util:get-rt-memory-used-size
::: incudine.util:get-foreign-sample-max-size
::: incudine.util:get-foreign-sample-free-size
::: incudine.util:get-foreign-sample-used-size
*** Finalization
::: with-cleanup
::: without-cleanup
::: dynamic-incudine-finalizer-p
::: incudine-finalize
::: incudine-cancel-finalization
*** Cons Pool
::: incudine.util:cons-pool
::: incudine.util:make-cons-pool
::: incudine.util:cons-pool-pop-cons
::: incudine.util:cons-pool-push-cons
::: incudine.util:cons-pool-pop-list
::: incudine.util:cons-pool-push-list
::: incudine.util:cons-pool-size
::: incudine.util:expand-cons-pool
**** Realtime Cons Pool
::: incudine.util:rt-global-pool-pop-cons
::: incudine.util:rt-global-pool-push-cons
::: incudine.util:rt-global-pool-pop-list
::: incudine.util:rt-global-pool-push-list
**** Non-Realtime Cons Pool
::: incudine.util:nrt-global-pool-pop-cons
::: incudine.util:nrt-global-pool-push-cons
::: incudine.util:nrt-global-pool-pop-list
::: incudine.util:nrt-global-pool-push-list
**** Tlist
::: incudine.util:make-tlist
::: incudine.util:tlist-empty-p
::: incudine.util:tlist-add-left
::: incudine.util:tlist-add-right
::: incudine.util:tlist-left
::: incudine.util:tlist-remove-left
::: incudine.util:tlist-right
*** Foreign Pool
::: incudine.external:init-foreign-memory-pool
::: incudine.external:destroy-foreign-memory-pool
::: incudine.external:foreign-alloc-ex
::: incudine.external:foreign-realloc-ex
::: incudine.external:foreign-free-ex
::: incudine.external:get-foreign-max-size
::: incudine.external:get-foreign-used-size
*** Consing
::: incudine.util:get-bytes-consed-in
#+texinfo: @page
** Realtime
::: incudine.util:*block-size-hook*
::: set-rt-block-size
::: set-max-buffer-size
::: rt-loop-callback
::: rt-silent-errors
::: rt-start
::: rt-stop
::: rt-status
::: *rt-thread-start-hook*
::: *rt-thread-exit-hook*
::: rt-cpu
::: recover-suspended-audio-cycles-p
::: rt-buffer-size
::: rt-sample-rate
::: rt-xruns
::: rt-time-offset
::: incudine.external:rt-cycle-start-time
::: incudine.external:rt-client
::: incudine.util:rt-eval
::: incudine.util:rt-thread-p
::: incudine.util:*rt-thread*
::: incudine.util:*nrt-thread*
::: incudine.util:*fast-nrt-thread*
::: incudine.util:*rt-priority*
::: incudine.util:*nrt-priority*
::: incudine.util:*fast-nrt-priority*
*** Receiver
::: responder
::: make-responder
::: make-osc-responder
::: add-responder
::: remove-responder
::: all-responders
::: remove-all-responders
::: receiver
::: receiver-stream
::: remove-receiver
::: all-receivers
::: remove-all-receivers
::: recv-functions
::: recv-start
::: recv-stop
::: recv-status
#+texinfo: @page
** Multithreaded Synchronization
*** Lock-Free FIFO
::: nrt-funcall
::: fast-nrt-funcall
::: rt-funcall
::: fast-rt-funcall
::: incudine.util:barrier
::: incudine.util:compare-and-swap
*** Spinlock Support
::: incudine.util:spinlock
::: incudine.util:make-spinlock
::: incudine.util:spinlock-name
::: incudine.util:acquire-spinlock
::: incudine.util:try-acquire-spinlock
::: incudine.util:release-spinlock
::: incudine.util:with-spinlock-held
#+texinfo: @page
** Scheduling
::: at
::: aat
::: with-schedule
::: unschedule-if
::: flush-pending
::: flush-all-fifos
*** Earliest Deadline First Scheduling
::: incudine.edf:node
::: incudine.edf:make-node
::: incudine.edf:heap
::: incudine.edf:*heap*
::: incudine.edf:*heap-size*
::: incudine.edf:make-heap
::: incudine.edf:heap-empty-p
::: incudine.edf:heap-count
::: incudine.edf:+root-node+
::: incudine.edf:schedule-at
::: incudine.edf:sched-loop
::: incudine.edf:next-time
::: incudine.edf:last-time
::: incudine.edf:add-flush-pending-hook
::: incudine.edf:remove-flush-pending-hook
::: incudine.edf:reduce-heap-pool
#+texinfo: @page
** DSP Graph
::: node
::: node-p
::: *root-node*
::: node-id
::: node-name
::: live-nodes

#+attr_texinfo: :options {Method} free node
#+begin_deffn
Deallocate the ~node~.

~node~ is a ~node~ structure or the integer identifier of the node.
#+end_deffn

::: node-free-all
::: null-node-p
::: node-gain
::: node-enable-gain-p
::: *node-enable-gain-p*
::: node-fade-time
::: incudine.util:*fade-time*
::: node-fade-curve
::: incudine.util:*fade-curve*
::: node-fade-in
::: node-fade-out
::: node-segment
::: node-release-phase-p
::: node-start-time
::: node-uptime
::: next-node-id
::: free-hook
::: stop-hook
::: group
::: make-group
::: group-p
::: dograph
::: dogroup
::: move
::: after-p
::: before-p
::: head-p
::: tail-p
::: play

#+texinfo: @noindent
Example: low-passed noise with single-float values
(no consing on 64-bit platforms).

#+begin_example
(set-rt-block-size 1)
(rt-start)

(play
  (let ((y0 0.0)
        (y1 0.0))
    (declare (single-float y0 y1))
    (lambda ()
      (setf y0 (- (random .04) .02))
      (setf y1 (+ y0 (* .995 y1)))
      (incf (audio-out 0) (sample y1))
      ;; Consing if the function returns a double-float value.
      (values))))
#+end_example

#+texinfo: @noindent
A similar example with buses and double-float values:

#+begin_example
(rt-start)

(play
  (symbol-macrolet ((y0 (bus 0))
                    (y1 (bus 1))
                    (coef (bus 2)))
    (setf y1 (sample 0))
    (setf coef (sample .995))
    (lambda ()
      (setf y0 (sample (- (random .04) .02)))
      (setf y1 (+ y0 (* coef y1)))
      (incf (audio-out 0) y1)
      (values))))
#+end_example

::: stop
::: pause
::: unpause
::: pause-p
::: done-p
::: reinit
::: dump

#+texinfo: @noindent
Example: DSP cycle on demand through ~unpause~

#+begin_example
(dsp! cycle-on-demand ()
  (with ((i 1))
    (declare (fixnum i))
    (nrt-msg warn "DSP cycle number ~D" i)
    (incf i)
    (pause (dsp-node))))

(rt-start)

(cycle-on-demand :id 1)  ; WARN: DSP cycle number 1
(pause-p 1)
;; => T

(dump (node 0))
;; group 0
;;     node 1 (pause)
;;       CYCLE-ON-DEMAND

(unpause 1)              ; WARN: DSP cycle number 2
(unpause 1)              ; WARN: DSP cycle number 3
(unpause 1)              ; WARN: DSP cycle number 4

(reinit 1)

(unpause 1)              ; WARN: DSP cycle number 1
(unpause 1)              ; WARN: DSP cycle number 2
(unpause 1)              ; WARN: DSP cycle number 3

(free 1)
#+end_example

::: control-getter
::: control-setter
::: control-list
::: control-names
::: control-value
::: control-pointer
::: set-control
::: set-controls
#+texinfo: @page
** Logging
::: incudine.util:*logger-stream*
::: incudine.util:*null-output*
::: incudine.util:*logger-force-output-p*
::: incudine.util:msg
::: incudine.util:nrt-msg
::: incudine.util:logger-level
::: incudine.util:logger-time
::: incudine.util:logger-time-function
::: incudine.util:default-logger-time-function
::: incudine.util:with-logger
#+texinfo: @page
** defun*, lambda* and defmacro*
~defun*~, ~lambda*~ and ~defmacro*~ are inspired by the extensions
define*, lambda* and define-macro* in Bill Schottstaedt's Scheme
implementation s7 [fn:lambda-star].

#+texinfo: @noindent
Some examples from s7.html translated to CL:

#+begin_example
(defun* hi (a (b 32) (c "hi")) (list a b c))

(hi 1)             ; => (1 32 "hi")
(hi :b 2 :a 3)     ; => (3 2 "hi")
(hi 3 2 1)         ; => (3 2 1)

(defun* foo ((a 0) (b (+ a 4)) (c (+ a 7))) (list a b c))

(foo :b 2 :a 60)   ; => (60 2 67)

(defun* foo (&rest a &rest b) (mapcar #'+ a b))

(foo 1 2 3 4 5)    ; => (3 5 7 9)

(defun* foo ((b 3) &rest x (c 1)) (list b c x))

(foo 32)           ; => (32 1 NIL)
(foo 1 2 3 4 5)    ; => (1 3 (2 3 4 5))

(funcall (lambda* ((b 3) &rest x (c 1) . d) (list b c x d)) 1 2 3 4 5)
; => (1 3 (2 3 4 5) (4 5))

(defmacro* add-2 (a (b 2)) `(+ ,a ,b))

(add-2 1 3)        ; => 4
(add-2 1)          ; => 3
(add-2 :b 3 :a 1)  ; => 4
#+end_example

::: incudine.util:defun*
::: incudine.util:lambda*
::: incudine.util:defmacro*
::: incudine.util:lambda-list-to-star-list

[fn:lambda-star]
  The text of the doc-string in ~defun*~ is copied/edited from
  the s7.html file provided with the source code:

    ftp://ccrma-ftp.stanford.edu/pub/Lisp/s7.tar.gz


#+texinfo: @page
** Sharp-T Reader Macro
::: enable-sharp-t-syntax
#+texinfo: @page
** Numeric Types
::: incudine.util:sample
::: incudine.util:positive-sample
::: incudine.util:non-positive-sample
::: incudine.util:negative-sample
::: incudine.util:non-negative-sample
::: incudine.util:limited-sample
::: incudine.util:maybe-limited-sample
::: incudine.util:least-negative-sample
::: incudine.util:most-negative-sample
::: incudine.util:least-positive-sample
::: incudine.util:most-positive-sample
::: incudine.util:frame
::: incudine.util:bus-number
::: incudine.util:channel-number
::: incudine.util:non-negative-fixnum64
::: incudine.util:most-positive-fixnum64
#+texinfo: @page
** Constants
::: incudine.util:+sample-zero+
::: incudine.util:+twopi+
::: incudine.util:+rtwopi+
::: incudine.util:+half-pi+
::: incudine.util:+log001+
::: incudine.util:+sqrt2+
::: incudine.util:+foreign-sample-size+
::: incudine.util:+foreign-complex-size+
::: incudine.util:+pointer-size+
::: incudine.util:+pointer-address-type+
::: incudine.util:+table-maxlen+
::: incudine.util:+phase-mask+
::: incudine.util:+max-lobits+
::: incudine.util:+rad2inc+
#+texinfo: @page
** Utilities
::: incudine.util:incudine-version
::: incudine.util:incudine-version->=
::: deprecated-symbol-names
::: init
::: incudine.util:exit
::: incudine.util:*reduce-warnings*
::: incudine.util:reduce-warnings
::: incudine.external:errno-to-string
::: block-size
::: dsp-seq
::: circular-shift
::: quantize
::: incudine.util:pow
::: incudine.util:linear-interp
::: incudine.util:cubic-interp
::: incudine.util:cos-interp
::: incudine.util:hz->radians
::: incudine.util:radians->hz
::: incudine.util:db->linear
::: incudine.util:linear->db
::: incudine.util:sample->fixnum
::: incudine.util:sample->int
::: incudine.util:float->fixnum
::: incudine.util:t60->pole
::: incudine.external:complex-to-polar
::: incudine.external:polar-to-complex
::: incudine.util:sort-samples
::: incudine.util:rationalize*
::: incudine.util:parse-float
::: incudine.util:dochannels
::: incudine.util:smp-ref
::: incudine.util:power-of-two-p
::: incudine.util:next-power-of-two
::: incudine.util:*sample-rate*
::: incudine.util:*sample-duration*
::: incudine.util:*sample-rate-hook*
::: incudine.util:set-sample-rate
::: incudine.util:set-sample-duration
::: incudine.util:*cps2inc*
::: incudine.util:*twopi-div-sr*
::: incudine.util:*sr-div-twopi*
::: incudine.util:*pi-div-sr*
::: incudine.util:*minus-pi-div-sr*
::: incudine.util:*sound-velocity*
::: incudine.util:*r-sound-velocity*
::: incudine.util:*sound-velocity-hook*
::: incudine.util:set-sound-velocity
::: incudine.util:seed-random-state
::: incudine.util:thread-affinity
::: incudine.util:thread-priority
::: incudine.util:with-pinned-objects
::: incudine.util:without-interrupts
#+texinfo: @page
** Analysis
*** Analysis Structure
::: ana:analysis
::: ana:analysis-p
::: ana:analysis-input-buffer
::: ana:analysis-input-buffer-size
::: ana:analysis-output-buffer
::: ana:analysis-output-buffer-size
::: ana:analysis-time
::: ana:touch-analysis
::: ana:discard-analysis
*** Analysis Buffer
::: ana:abuffer
::: ana:make-abuffer
::: ana:abuffer-p

#+attr_texinfo: :options {Method} free abuffer
#+begin_deffn
Deallocate the ~abuffer~.
#+end_deffn

#+attr_texinfo: :options {Method} free-p abuffer
#+begin_deffn
Return ~t~ if the ~abuffer~ is deallocated.
#+end_deffn

::: ana:abuffer-data
::: ana:abuffer-size
::: ana:abuffer-nbins
::: ana:abuffer-link
::: ana:abuffer-time
::: ana:abuffer-normalized-p
::: ana:abuffer-complex
::: ana:abuffer-polar
::: ana:abuffer-imagpart
::: ana:abuffer-realpart
::: ana:compute-abuffer
::: ana:update-linked-object
::: ana:touch-abuffer
::: ana:discard-abuffer
*** Fast Fourier Transform
::: ana:fft
::: ana:make-fft
::: ana:fft-p
::: ana:fft-size
::: ana:fft-plan
::: ana:fft-window
::: ana:fft-input
::: ana:compute-fft

#+attr_texinfo: :options {Method} circular-shift fft n
#+begin_deffn
Perform a circular shift of length ~n~ during ~compute-fft~.
#+end_deffn

::: ana:ifft
::: ana:make-ifft
::: ana:ifft-p
::: ana:ifft-size
::: ana:ifft-plan
::: ana:ifft-window
::: ana:ifft-output
::: ana:compute-ifft

#+attr_texinfo: :options {Method} circular-shift ifft n &key before-windowing-p
#+begin_deffn
Perform a circular shift of length ~n~.

If ~before-windowing-p~ is T, perform the shift during ~compute-ifft~,
before the application of the window.
#+end_deffn

::: ana:window-size
::: ana:window-function
::: ana:hop-size
::: ana:*fft-default-window-function*
::: ana:rectangular-window
::: ana:dofft
::: ana:dofft-polar
::: ana:dofft-complex
::: ana:new-fft-plan
::: ana:+fft-plan-fast+
::: ana:+fft-plan-best+
::: ana:+fft-plan-optimal+
::: ana:remove-fft-plan
::: ana:get-fft-plan
::: ana:fft-plan-list
*** Short-Time Fourier Transform and Phase Vocoder
::: ana:pvbuffer
::: ana:make-pvbuffer
::: ana:make-part-convolve-buffer
::: ana:make-fft-from-pvbuffer
::: ana:make-ifft-from-pvbuffer
::: ana:stft

#+attr_texinfo: :options {Method} free pvbuffer
#+begin_deffn
Deallocate the ~pvbuffer~.
#+end_deffn

#+attr_texinfo: :options {Method} free-p pvbuffer
#+begin_deffn
Return ~t~ if the ~pvbuffer~ is deallocated.
#+end_deffn

::: ana:pvbuffer-window

#+attr_texinfo: :options {Method} ana:window-size pvbuffer
#+begin_deffn
Return the analysis window size of the pvbuffer frames. Setfable.
#+end_deffn

#+attr_texinfo: :options {Method} ana:window-function pvbuffer
#+begin_deffn
Return the analysis window function of the pvbuffer frames. Setfable.
#+end_deffn

#+attr_texinfo: :options {Method} ana:hop-size pvbuffer
#+begin_deffn
Return the STFT frame offset of the pvbuffer. Setfable.
#+end_deffn

::: ana:pvbuffer-data
::: ana:fill-pvbuffer
::: ana:copy-pvbuffer-data
::: ana:pvbuffer-size
::: ana:pvbuffer-channels
::: ana:pvbuffer-frames
::: ana:pvbuffer-sample-rate
::: ana:pvbuffer-fft-size
::: ana:pvbuffer-block-size
::: ana:pvbuffer-data-type
::: ana:pvbuffer-scale-factor
::: ana:normalize-pvbuffer
::: ana:pvbuffer-normalized-p
::: ana:pvbuffer-save
::: ana:pvbuffer-load
#+texinfo: @page
** GEN Routines
*** Analysis
::: gen:analysis
*** Envelope
::: gen:envelope
*** Filter
::: gen:fir
::: gen:hilbert

Example:

#+begin_example
(in-package :scratch)

(define-vug ssb-am (input (fir-hilbert buffer) frequency-shift)
  "Single side-band AM."
  (with ((order (ash (logior (1- (buffer-size fir-hilbert)) 1) -1)))
    (declare (type non-negative-fixnum order))
    (- (* (delay-s input 4000 order) (sine frequency-shift 1 +half-pi+))
       (* (direct-convolve input fir-hilbert) (sine frequency-shift)))))

(dsp! ssb-am-test ((fir-hilbert buffer) frequency-shift)
  "Modulation of the sound obtained from the first input channel."
  (out (ssb-am (butter-lp (audio-in 0) 8000) fir-hilbert frequency-shift)))

;; Order 149 => causal FIR filter with 149*2 + 1 coefficients.
(defvar *fir-hilbert* (make-buffer 299 :fill-function (gen:hilbert)))

(defun set-fir-hilbert-window-function (func)
  (fill-buffer *fir-hilbert* (gen:hilbert :window-function func)))

(rt-start)

(ssb-am-test *fir-hilbert* 567)

(rt-eval () (set-fir-hilbert-window-function #'rectangular-window))

(rt-eval () (set-fir-hilbert-window-function (gen:kaiser 6)))
#+end_example

*** Partials
::: gen:partials
::: gen:gbuzz
::: gen:chebyshev-1
::: incudine.util:cheb
*** Polynomial
::: gen:polynomial
*** Random
::: gen:all-random-distributions
::: gen:rand
::: gen:rand-args
*** Windows
::: gen:defwindow
::: gen:symmetric-loop
::: gen:symmetric-set
::: gen:bartlett
::: gen:blackman
::: gen:gaussian
::: gen:hamming
::: gen:hanning
::: gen:kaiser
::: gen:sinc
::: gen:dolph-chebyshev
::: gen:sine-window
#+texinfo: @page
** MIDI
::: midiout
::: midiout-sysex
::: midiin-sysex-octets

Example:

#+begin_example
(in-package :scratch)

;; Test with PortMidi.
(defvar *midiin-test* (pm:open (pm:get-default-input-device-id)))

(defun verbose-responder (status data1 data2)
  (cond ((= status #xf0)
         (format *logger-stream* "MIDI SysEx: ~A~%"
                 (midiin-sysex-octets *midiin-test*)))
        ((>= status #x80)
         (format *logger-stream* "MIDI event: ~D ~D ~D~%"
                 status data1 data2)))
  (force-output *logger-stream*))

(make-responder *midiin-test* #'verbose-responder)

(recv-start *midiin-test*)

;; Send a MIDI SysEx message from a sequencer...

;; Get the octets of the last received MIDI SysEx.
(midiin-sysex-octets *midiin-test*)

(recv-stop *midiin-test*)
(remove-all-responders *midiin-test*)
(remove-receiver *midiin-test*)
(pm:close *midiin-test*)

;; The same test with JACK MIDI.
(setf *midiin-test* (jackmidi:open))

;; Start JACK.
(rt-start)

(make-responder *midiin-test* #'verbose-responder)

(recv-start *midiin-test*)

;; Connect a sequencer to the JACK MIDI input port "incudine:midi_in",
;; send a MIDI SysEx message from the sequencer...

;; Octets of the last received MIDI SysEx.
(midiin-sysex-octets *midiin-test*)

(recv-stop *midiin-test*)
(remove-all-responders *midiin-test*)
(remove-receiver *midiin-test*)
(jackmidi:close *midiin-test*)
(rt-stop)
#+end_example

::: midi-tuning-sysex
::: with-midi-table-data
#+texinfo: @page
** Mouse Support
Currently, mouse pointer support requires X window system.

::: incudine.util:mouse-start
::: incudine.util:mouse-stop
::: incudine.util:mouse-status
::: incudine.util:get-mouse-x
::: incudine.util:get-mouse-y
::: incudine.util:get-mouse-button
#+texinfo: @page
** Voicer
::: voicer:voicer
::: voicer:create
::: voicer:update

#+attr_texinfo: :options {Method} free voicer
#+begin_deffn
Deallocate the ~voicer~.
#+end_deffn

::: voicer:empty-p
::: voicer:full-p
::: voicer:polyphony
::: voicer:steal-voice-mode
::: voicer:trigger
::: voicer:release
::: voicer:control-list
::: voicer:control-names
::: voicer:control-value
::: voicer:set-controls
::: voicer:define-map
::: voicer:remove-map
::: voicer:remove-all-maps
::: voicer:panic
::: voicer:midi-event
::: voicer:midi-bind
::: voicer:scale-midi-amp
::: voicer:fill-amp-table
::: voicer:fill-freq-table
#+texinfo: @page
** Virtual Unit Generator
::: vug:vug
::: vug:vug-macro
::: vug:vug-p
::: vug:vug-macro-p
::: vug:define-vug
::: vug:define-vug-macro
::: vug:vug-lambda-list
::: vug:rename-vug
::: vug:destroy-vug
::: vug:all-vug-names
::: vug:fix-vug
::: vug:vug-input
::: vug:with-vug-inputs
::: vug:vuglet
::: vug:with
::: vug:with-follow
::: vug:without-follow
::: vug:init-only
::: vug:external-variable
::: vug:initialize
::: vug:tick
::: vug:update
::: vug:foreach-channel
::: vug:current-channel
::: vug:foreach-frame
::: vug:current-frame
::: vug:current-sample
::: vug:current-input-sample
::: vug:foreach-tick
::: vug:maybe-expand
::: vug:get-pointer
::: vug:dsp-node
::: vug:free-self
::: vug:make-i32-array
::: vug:make-u32-array
::: vug:make-i64-array
::: vug:make-u64-array
::: vug:make-f32-array
::: vug:make-f64-array
::: vug:make-pointer-array
::: vug:maybe-make-i32-array
::: vug:maybe-i32-ref
::: vug:maybe-make-u32-array
::: vug:maybe-u32-ref
::: vug:foreign-array-type-of
::: vug:foreign-length
::: vug:samples-zero
#+texinfo: @page
** Built-in Virtual Unit Generators
*** Output
::: vug:out
::: vug:cout
::: vug:frame-out
::: vug:node-out
*** Generator
::: vug:buzz
::: vug:gbuzz
::: vug:impulse
::: vug:osc
::: vug:oscr
::: vug:oscrc
::: vug:oscrq
::: vug:oscrs
::: vug:phasor
::: vug:phasor-loop
::: vug:pulse
::: vug:sine
*** Noise
::: vug:white-noise
::: vug:pink-noise
::: vug:fractal-noise
::: vug:crackle
::: vug:rand
*** Amplitude
::: vug:env-follower
::: vug:rms
::: vug:gain
::: vug:balance
*** Envelope
::: vug:decay
::: vug:decay-2
::: vug:line
::: vug:expon
::: vug:envelope
*** Panpot
::: vug:fpan2
::: vug:pan2
::: vug:stereo
*** Delay
::: vug:buf-delay-s
::: vug:buf-delay
::: vug:buf-vdelay
::: vug:delay1
::: vug:delay-s
::: vug:delay
::: vug:vdelay
::: vug:vtap
::: vug:delay-feedback
::: vug:allpass-s
::: vug:allpass
::: vug:vallpass
::: vug:fb-comb
::: vug:ff-comb
*** Filter
::: vug:~
::: vug:apf
::: vug:biquad
::: vug:bpf
::: vug:butter-bp
::: vug:butter-br
::: vug:butter-hp
::: vug:butter-lp
::: vug:cs-atone
::: vug:cs-tone
::: vug:dcblock
::: vug:diff
::: vug:direct-convolve
::: vug:fofilter
::: vug:hi-shelf
::: vug:hpf
::: vug:integrator
::: vug:lag
::: vug:lag-ud
::: vug:low-shelf
::: vug:lpf
::: vug:lpf18
::: vug:maf
::: vug:median
::: vug:moogff
::: vug:moogladder
::: vug:nlf2
::: vug:notch
::: vug:part-convolve
::: vug:peak-eq
::: vug:pole
::: vug:pole*
::: vug:reson
::: vug:resonr
::: vug:resonz
::: vug:ringr
::: vug:ringz
::: vug:svf
::: vug:two-pole
::: vug:two-zero
::: vug:zero
::: vug:zero*
*** Conversion
::: vug:lin->lin
::: vug:lin->exp
*** Buffer
::: vug:buffer-read
::: vug:buffer-write
::: vug:buffer-play
::: vug:buffer-frame
*** Frame
::: vug:make-frame
::: vug:frame-ref
::: vug:multiple-sample-bind
::: vug:samples
*** Distortion
::: vug:clip
::: vug:nclip
::: vug:wrap
::: vug:nwrap
::: vug:mirror
::: vug:nmirror
*** Analysis
::: vug:centroid
::: vug:flatness
::: vug:flux
::: vug:rolloff
::: vug:spectral-rms
*** Chaos
::: vug:cusp
::: vug:fb-sine
::: vug:gbman
::: vug:gendy
::: vug:henon
::: vug:latoocarfian
::: vug:lin-cong
::: vug:lorenz
::: vug:quad-map
::: vug:standard-map
*** MIDI
::: vug:*linear-midi-table*
::: vug:midi-note-p
::: vug:midi-note-off
::: vug:midi-note-off-p
::: vug:midi-note-on
::: vug:midi-note-on-p
::: vug:midi-keynum
::: vug:midi-lowest-keynum
::: vug:midi-highest-keynum
::: vug:midi-velocity
::: vug:midi-amp
::: vug:midi-cps
::: vug:midi-cc
::: vug:midi-cc-p
::: vug:midi-program
::: vug:midi-program-p
::: vug:midi-pitch-bend
::: vug:midi-pitch-bend-p
::: vug:midi-poly-aftertouch
::: vug:midi-poly-aftertouch-p
::: vug:midi-global-aftertouch
::: vug:midi-global-aftertouch-p
::: vug:lin-midi-cc
::: vug:lin-midi-pitch-bend
::: vug:lin-midi-poly-aftertouch
::: vug:lin-midi-global-aftertouch
::: vug:exp-midi-cc
::: vug:exp-midi-pitch-bend
::: vug:exp-midi-poly-aftertouch
::: vug:exp-midi-global-aftertouch
::: vug:played-midi-note
::: vug:reset-midi-notes
*** Misc
::: vug:counter
::: vug:downsamp
::: vug:interpolate
::: vug:samphold
::: vug:snapshot
::: vug:with-control-period
*** Mouse
::: vug:mouse-x
::: vug:mouse-y
::: vug:mouse-button
::: vug:lin-mouse-x
::: vug:lin-mouse-y
::: vug:exp-mouse-x
::: vug:exp-mouse-y
*** Foreign Plugin
::: incudine.vug-foreign:plugin
::: incudine.vug-foreign:make-plugin
::: incudine.vug-foreign:plugin-instance
::: incudine.vug-foreign:plugin-instance-pointer
::: incudine.vug-foreign:plugin-port-pointer
::: incudine.vug-foreign:port
::: incudine.vug-foreign:+input-port+
::: incudine.vug-foreign:+output-port+
::: incudine.vug-foreign:+audio-port+
::: incudine.vug-foreign:+control-port+
::: incudine.vug-foreign:+midi-port+
::: incudine.vug-foreign:+event-port+
::: incudine.vug-foreign:input-port-p
::: incudine.vug-foreign:output-port-p
::: incudine.vug-foreign:audio-port-p
::: incudine.vug-foreign:control-port-p
::: incudine.vug-foreign:midi-port-p
::: incudine.vug-foreign:event-port-p
::: incudine.vug-foreign:make-port
::: incudine.vug-foreign:port-loop
::: incudine.vug-foreign:with-vug-plugin
::: incudine.vug-foreign:doc-string
::: incudine.vug-foreign:update-io-number
#+texinfo: @page
** Unit Generator
::: vug:ugen
::: vug:define-ugen
::: vug:ugen-debug
::: vug:ugen-lambda-list
::: vug:*eval-some-specials-p*
::: vug:*specials-to-eval*
::: vug:compile-vug
::: vug:compiled-vug-p
::: vug:rename-ugen
::: vug:destroy-ugen
::: vug:all-ugen-names
::: vug:fix-ugen
::: vug:ugen-instance
::: vug:with-ugen-instance
::: vug:with-ugen-instances

#+attr_texinfo: :options {Method} free ugen-instance
#+begin_deffn
Deallocate the ~ugen-instance~.
#+end_deffn

#+attr_texinfo: :options {Method} free-p ugen-instance
#+begin_deffn
Return ~t~ if the ~ugen-instance~ is deallocated.
#+end_deffn

::: vug:ugen-perf-function
::: vug:ugen-reinit-function
::: vug:ugen-return-pointer
::: vug:ugen-control-pointer
::: vug:define-ugen-control-getter
::: vug:define-ugen-control-setter
#+texinfo: @page
** DSP
::: vug:*update-dsp-instances-p*
::: vug:dsp!
::: vug:dsp-debug
::: vug:dsp-lambda-list
::: vug:metadata

Example:

#+begin_example
(in-package :scratch)

(dsp! panner ((buffer buffer) pan)
  (:defaults (incudine-missing-arg "BUFFER") 0.5)
  (:metadata :inputs 1)
  (:metadata :outputs 2)
  (with-samples ((alpha (* +half-pi+ pan))
                 (left (cos alpha))
                 (right (sin alpha)))
    (loop for i below (buffer-size buffer) by 2 do
         (setf (buffer-value buffer (1+ i))
               (* right (buffer-value buffer i)))
         (setf (buffer-value buffer i)
               (* left (buffer-value buffer i))))))

(metadata 'panner)
;; => ((:INPUTS . 1) (:OUTPUTS . 2))

(defparameter *effect-chain-buffer*
  (make-buffer (block-size)
    :channels (max (metadata 'panner :inputs)
                   (metadata 'panner :outputs))))
#+end_example

::: vug:destroy-dsp
::: vug:free-dsp-instances
::: vug:all-dsp-names
#+texinfo: @page
** The rule of the first expansion
If a variable is bound to a performance-time value, for example:

#+begin_example
(define-vug first-expansion-test ((rain-p boolean))
  (with-samples ((s (performance-time-humidity)))
    (out (* s .5) (* s .3))))
#+end_example

#+texinfo: @noindent
the variable is set the first time that it appears within the body of
the definition:

#+begin_example
(out (* (setf s (performance-time-humidity)) .5)
     (* s .3))
#+end_example

#+texinfo: @noindent
It is generally correct. Unfortunately, there is the posibility to
introduce a bug if the performance-time variable is updated inside a
branching, for example:

#+begin_example
(define-vug first-expansion-test ((rain-p boolean))
  (with-samples ((s (performance-time-humidity)))
    (out (if rain-p s (* s 0.15)))))
#+end_example

#+texinfo: @noindent
In this case, the result is

#+begin_example
(out (if rain-p
         (setf s (performance-time-humidity))
         (* s 0.15)))
#+end_example

#+texinfo: @noindent
where S is performance-time only if it's raining. The simplest solution
for this example is to explicitally set the variable before branching:

#+begin_example
(define-vug first-expansion-test ((rain-p boolean))
  (with-samples (s)
    (setf s (performance-time-humidity))
    (out (if rain-p s (* s 0.15)))))
#+end_example

#+texinfo: @noindent
However the problem persists with a VUG input (obviously only
if it is performance-time):

#+begin_example
(define-vug first-expansion-test (s (rain-p boolean))
  (out (if rain-p s (* s 0.15))))
#+end_example

#+texinfo: @noindent
The definitive solution is to indicate where the variable is
updated if necessary (the VUG input is possibly set before this
point):

#+begin_example
(define-vug first-expansion-test (s (rain-p boolean))
  (maybe-expand s)
  (out (if rain-p s (* s 0.15))))
#+end_example

#+texinfo: @noindent
Note: it is also possible to force the setting of a variable,
for example:

#+begin_example
(define-vug snapshot ((gate fixnum) (start-offset fixnum) input)
  (with-samples ((next-time (init-only (+ (now) gate)))
                 (value (sample 0)))
    (initialize (setf next-time (+ (now) start-offset)))
    (cond ((plusp gate)
           (unless (< (now) next-time)
             (setf value (update input))
             (setf next-time (+ (now) gate))))
          ((minusp gate)
           (setf value (update input) gate 0)))
    value))
#+end_example

#+texinfo: @noindent
in this case the performance-time loop is:

#+begin_example
(labels ((set-input[gensym-ed] ()
           (setf input ...)))
  (cond ((plusp gate)
         (unless (< (now) next-time)
           (setf value (set-input[gensym-ed]))
           (setf next-time (+ (now) gate))))
        ((minusp gate)
         (setf value (set-input[gensym-ed]) gate 0)))
  value))
#+end_example

** Mixdown
::: incudine.util:*bounce-to-disk-guard-size*
::: bounce-to-disk
::: bounce-to-buffer
::: with-nrt
#+texinfo: @page
** Rego File
A rego file can contain time-tagged lisp functions, lisp statements,
arbitrary score statements and lisp tags. Besides, the rego file
format supports the [[https://orgmode.org][Org]] markup language.
It is possible to edit and organize score files with spreedsheet-like
capabilities, headlines, unordered lists, blocks, properties,
hyperlinks, todo items, tags, deadlines, scheduling, etc.

#+texinfo: @noindent
The syntax of a time-tagged lisp function is:

#+texinfo: @exampleindent 4
#+begin_example
start-time-in-beats [time-increment]* function-name [arg1] [arg2] ...
#+end_example

#+texinfo: @noindent
The optional numbers between ~start-time-in-beats~ and ~function-name~
increment the start time. For example:

#+texinfo: @exampleindent 4
#+begin_example
0.8          foo 220 .2
2.5 .15      foo 440 .5
3.2 .25 -.11 foo 432 .2
#+end_example

#+texinfo: @noindent
is equivalent to

#+texinfo: @exampleindent 4
#+begin_example
0.8              foo 220 .2
(+ 2.5 .15)      foo 440 .5
(+ 3.2 .25 -.11) foo 432 .2
#+end_example

#+texinfo: @noindent
A line comment starts with a semicolon. A line continuation requires
the character ~\~ at the end of the line. The comments and the blocks
in Org markup language are ignored too.

#+texinfo: @noindent
If the symbol ~//~ is used to separate the functions with the same
time-tag, the result is a polyphonic vertical sequencer in text files.
A quoted function name is ignored; useful to mute an instrument.

#+texinfo: @noindent
For example:

#+texinfo: @exampleindent 4
#+begin_example
2.5 foo 440 .08 // bar 550 .1 // 'baz 660 .05 // sev 770 .1
3.2                           //  baz 330 .03
4.5 foo 220 .02                               // sev 772 .07
#+end_example

#+texinfo: @noindent
is equivalent to

#+texinfo: @exampleindent 4
#+begin_example
2.5 foo 440 .08
2.5 bar 550 .1
2.5 sev 770 .1
3.2 baz 330 .03
4.5 foo 220 .02
4.5 sev 772 .07
#+end_example

#+texinfo: @noindent
Example with common start-time and different delay-time:

#+begin_example
0 .11 i1 1 2 3 // .25 i2 1 2 3 //  .05 i3 1 2 3
1
2     i1 1 2 3 // .05 i2 1 2 3 // -.15 i3 1 2 3
3
#+end_example

#+texinfo: @noindent
is equivalent to

#+begin_example
0.05 i3 1 2 3
0.11 i1 1 2 3
0.25 i2 1 2 3
1.85 i3 1 2 3
2.00 i1 1 2 3
2.05 i2 1 2 3
#+end_example

#+texinfo: @noindent
An isolated number is not a lisp tag otherwise a time-tagged function
gets confused. A single column of numbers is useful for rhythm templates.

#+texinfo: @noindent
There are predefined variable bindings usable inside a rego file:

- SCORE-ARGS :: List of score function arguments.
- SCORE-REALTIME-P :: T if the events are scheduled in real-time.
- TEMPO-ENV :: Temporal envelope of the events.
- TIME :: Time offset in beats.

#+texinfo: @noindent
Note: we can use ~tempo-env~ within an event function only if the
event terminates before the end of the rego file.

#+texinfo: @noindent
The score statement ~:score-time:~ sets the variable ~time~.
The name is surrounded by colons, so it is also a valid property
in Org markup language. For example:

#+texinfo: @exampleindent 4
#+begin_example
:PROPERTIES:
:score-time: 8
:END:
#+end_example

is equivalent to

:    (setf time 8)

#+texinfo: @noindent
The score statement ~:score-start-time:~ sets the start time in beats.
The events scheduled before that time and the score start time of the
included files are ignored.

#+texinfo: @noindent
It is possible to create other variable bindings through
~with~ at the beginning of the score. For example:

#+texinfo: @exampleindent 4
#+begin_example
;;; test.rego
with (id 1) (last 4)

;; simple oscillators
0          simple 440 .2 :id id
1          simple 448 .2 :id (+ id 1)
(1- last)  simple 661 .2 :id (+ id 2)
last       free 0
#+end_example

#+texinfo: @noindent
We can also add a ~declare~ expression after the bindings.

#+texinfo: @noindent
The score statement ~:score-bindings:~ is an alias of ~with~.

#+texinfo: @noindent
The score statement ~:score-package:~ sets the name of the package
used to read the rest of the score lines. For example:

#+texinfo: @exampleindent 4
#+begin_example
:score-package: string-quartet
0 vla p1 p2 p3
0 vl  q1 q2 q3
#+end_example

#+texinfo: @noindent
is equivalent to

#+texinfo: @exampleindent 4
#+begin_example
0 string-quartet:vla string-quartet::p1 string-quartet::p2 string-quartet::p3
0 string-quartet:vl  string-quartet::q1 string-quartet::q2 string-quartet::q3
#+end_example

#+texinfo: @noindent
~dur~ is a local macro to convert the duration from
beats to seconds with respect to ~tempo-env~.

#+texinfo: @noindent
~tempo~ is a local macro to change the tempo of the score.
The syntax is

#+texinfo: @exampleindent 4
#+begin_example
(tempo bpm)
(tempo bpms beats &key curve loop-node release-node
                       restart-level real-time-p)
#+end_example

#+texinfo: @noindent
The score statement ~:score-tempo:~ is an alternative to the local
macro ~tempo~:

#+texinfo: @exampleindent 4
#+begin_example
:score-tempo: bpm
:score-tempo: bpms beats &key curve [...]
#+end_example

#+texinfo: @noindent
If a function created with ~regofile->function~ or
~regostring->function~ is scheduled in real-time:

#+texinfo: @exampleindent 4
#+begin_example
;; The real scheduled time is `(+ time latency)'.
(at time function-from-regofile ...)
#+end_example

#+texinfo: @noindent
there is a latency introduced during the creation of a temporary
queue for the score events (see also ~with-schedule~). If a precise
scheduling in real-time is required, the score statement
~:score-realtime-offset:~ sets the absolute time offset in samples
for the scheduled score events. For example, if the rego file
begins with the following lines:

#+texinfo: @exampleindent 4
#+begin_example
:score-tempo: '(180 95) '(4) :curve :exp
:score-realtime-offset: (tempo-sync #[4 b tempo-env 0])
#+end_example

#+texinfo: @noindent
a scheduled function is synchronized to a period of 4 beats.

#+texinfo: @noindent
The syntax to include the content of an external rego file is:

#+texinfo: @exampleindent 4
#+begin_example
include "regofile" [time] {value}* {(var value)}*
#+end_example

#+texinfo: @noindent
where ~time~ is an optional time offset in beats, and the variable
bindings set some score bindings of the included file. For example:

#+texinfo: @exampleindent 4
#+begin_example
include "phrase-7.rego"
include "phrase-7.rego" 4
include "phrase-7.rego" 8 (keynum 63) (channel 3)

;; Set the first score binding and CHANNEL in "phrase-7.rego".
include "phrase-7.rego" 12 68 (channel 3)

;; Set the first two score bindings in "phrase-7.rego".
include "phrase-7.rego" 16 70 3
#+end_example

#+texinfo: @noindent
~time~ and ~tempo-env~ are a parent's copy within an included rego file,
so we can locally change the temporal envelope and/or the time offset
without side effects. Moreover, all the local bindings and the labels
contained in a rego file continue to have lexical scope and dynamic
extent, therefore it is possible to include the same rego file multiple
times without name collisions.

#+texinfo: @noindent
A time-tagged string is an alternative syntax to include the content
of a rego file:

#+texinfo: @exampleindent 4
#+begin_example
time "regofile" {value}* {(var value)}*
#+end_example

#+texinfo: @noindent
There is not a specific limit on the depth of included rego files.

#+texinfo: @noindent
A score macro is defined with a macro block in Org markup language:

#+texinfo: @exampleindent 4
#+begin_example
#+begin_macro name
...
#+end_macro
#+end_example

#+texinfo: @noindent
The syntax for a score macro expansion is:

#+texinfo: @exampleindent 4
#+begin_example
name [time] {value}* {(var value)}*
#+end_example

#+texinfo: @noindent
or the time-tagged version:

#+texinfo: @exampleindent 4
#+begin_example
time name {value}* {(var value)}*
#+end_example

#+texinfo: @noindent
The inclusion of a rego file is equivalent to the expansion of a score
macro defined with the same file contents (dynamic extent bindings,
tempo, etc). For example:

#+texinfo: @exampleindent 4
#+begin_example
:score-tempo: 120

#+begin_macro macro-test
with x y z
:score-tempo: '(120 30) '(12) :curve :exp
0 test x
4 test y
8 test z
#+end_macro

16 bridge

|------------+------+---+---+---|
| !          | time | x | y | z |
|------------+------+---+---+---|
| macro-test |    0 | 1 | 2 | 3 |
| macro-test |   12 | 4 | 5 | 6 |
|------------+------+---+---+---|

30 free 0
#+end_example

#+texinfo: @noindent
is equivalent to

#+texinfo: @exampleindent 4
#+begin_example
0.0d0                test 1
2.542321754062445d0  test 2
6.0d0                test 4
6.578005980902809d0  test 3
8.0d0                bridge
8.542321754062446d0  test 5
12.578005980902809d0 test 6
15.0d0               free 0
#+end_example

#+texinfo: @noindent
A rego file ends after the last event or after a long pending event if
the duration is known (defined with the local macro ~dur~). For
example:

#+texinfo: @exampleindent 4
#+begin_example
0    ...
1.5  ...
3    ...
#+end_example

#+texinfo: @noindent
ends after 3 beats but

#+texinfo: @exampleindent 4
#+begin_example
0    ...
1.5  ... (dur 5) ...
3    ...
#+end_example

#+texinfo: @noindent
ends after 6.5 beats.

#+texinfo: @noindent
The score pages are delimited by the form feed character.
The score statement ~:score-pages:~ sets the pages to read (the
other pages are ignored). ~all~ and ~t~ mean "all the pages".

#+texinfo: @noindent
Example:

#+texinfo: @exampleindent 4
#+begin_example
:score-pages: 7
:score-pages: 3 7 8
:score-pages: all
#+end_example

#+texinfo: @noindent
~:score-pages:~ defaults to 1. In this case, a line with a form
feed character marks the end of score. For example, we can create
and edit a rego file in Emacs SES (Simple Emacs Spreadsheet) mode.

#+texinfo: @noindent
Note: the pages within a score macro block are not part of the
main score, and the pages within other blocks in Org markup
language are ignored.

#+texinfo: @noindent
~#|~ is an ignored score statement by default, therefore
the following ellipsislispy example is a valid score for
~regofile->*~

#+texinfo: @exampleindent 4
#+begin_example
#|
:score-pages: 2
|#

(defun i1
  ...)
(defun i2
  ...)

#|
Note: in this text ^L is not a real form feed char.
^L
;; second page
0 i1 ... // i2 ...
1 i1 ...
2 i2 ...
;; end of page
^L
|#

(defun i3
  ...)
;; etc...
#+end_example

#+texinfo: @noindent
The score statement ~:score-radix:~ sets the variable
~*read-base*~ to read the rest of the score lines.

#+texinfo: @noindent
~:score-radix:~ defaults to 10 if there is not a parent rego file.

#+texinfo: @noindent
Example:

#+texinfo: @exampleindent 4
#+begin_example
12 i2 60 100
15 i2 63 78

:score-radix: 16
00 i1 7f ff 1f 1a
0b i1 2b 08 0c 3c

;; Ratios are affected by *READ-BASE*
ff/1f i3 1/ff f/a

:score-radix: 2
00011010 add 10101010 11001011
#+end_example

#+texinfo: @noindent
Warning: we could introduce some bugs if ~:score-radix:~ is greater
than 10. For example:

#+texinfo: @exampleindent 4
#+begin_example
:score-radix: 16
0 cc 10 7f
1 foo 'babba
#+end_example

#+texinfo: @noindent
is equivalent to

#+texinfo: @exampleindent 4
#+begin_example
0 204 16 127
1 foo 764858
#+end_example

#+texinfo: @noindent
The score statement ~:score-float-format:~ sets the variable
~*read-default-float-format*~ to read the rest of the score lines.

#+texinfo: @noindent
~:score-float-format:~ defaults to ~double-float~ (the sample type)
if there is not a parent rego file.

#+texinfo: @noindent
Example:

#+texinfo: @exampleindent 4
#+begin_example
0 print (list 1.0 1.2345 1.125s3 123.456d0 1f-3 1d-3 1e-3 1.234l0)
;; => (1.0d0 1.2345d0 1125.0 123.456d0 0.001 0.001d0 0.001d0 1.234d0)

:score-float-format: single-float
0 print (list 1.0 1.2345 1.125s3 123.456d0 1f-3 1d-3 1e-3 1.234l0)
;; => (1.0 1.2345 1125.0 123.456d0 0.001 0.001d0 0.001 1.234d0)

,** double-float again
   :PROPERTIES:
   :score-float-format: double-float
   :END:

0 print (list 1.0 1.2345 1.125s3 123.456d0 1f-3 1d-3 1e-3 1.234l0)
;; => (1.0d0 1.2345d0 1125.0 123.456d0 0.001 0.001d0 0.001d0 1.234d0)

0 force-output
#+end_example

#+texinfo: @noindent
The score statement ~call~ pushes the return position on the stack
and transfers program control to the point labeled by a tag.
The score statement ~return~ transfers control to the return position
located on the top of the stack.

#+texinfo: @noindent
Syntax for ~call~ statement (a tag between ~[[]]~ is a facility for
the Org markup language):

#+texinfo: @exampleindent 4
#+begin_example
call tag
call tag time
call [[tag]] time                ; the target label is <<tag>>
call [[tag][description]] time   ; the target label is <<tag>>
#+end_example

#+texinfo: @noindent
Example:

#+texinfo: @exampleindent 4
#+begin_example
,* score
,** sequence
call p1 0
call [[p2][pattern two]] 1
call p3 1.5
call p1 2
return              ; end of score

,** pattern 1
p1
0 write-line "pattern 1" // force-output
call p3 .1
call p3 .25
return

,** pattern 2
<<p2>>
0 write-line "pattern 2" // force-output
return

,** pattern 3
p3
0 write-line "pattern 3" // force-output
return
#+end_example

::: defscore-statement
::: delete-score-statement
::: ignore-score-statements
::: *score-readtable*
::: regofile->sexp
::: regofile->function

Example:

#+begin_example
,* Score functions recursively scheduled
:PROPERTIES:
:score-bindings: (n (or (pop score-args) 12345)) \
                 (m (or (pop score-args) 16)) \
                 (local-call-p (pop score-args)) \
                 (freq (* m 100)) \
                 (next (if score-realtime-p 1/8 1/4)) \
                 (last (if score-realtime-p (- 4 1/8) 4))
:score-function-name: rego-function-name-test-1
:score-local-function-name: self
:score-tempo: 240
:score-realtime-offset: (tempo-sync #[1/4 beats tempo-env 0])
:END:

,#+begin_src incudine :results silent
  (dsp! rego-test-3 (freq amp dur)
    (stereo (* (envelope (make-perc .1 .9) 1 dur #'free)
               (sine freq amp))))
,#+end_src

,** Recursion of SELF

(unless (> m 0) (go end-of-score))

0 rego-test-3 (* freq (expt 2 3/12)) (/ m 20) (dur 1/5)
next self n (1- m) t

(if local-call-p (go end-of-score))

,** Recursion of REGO-FUNCTION-NAME-TEST-1

(unless (> n 0) (go end-of-score))

last rego-function-name-test-1 (1- n) 16

(if (< n 12345) (go end-of-score))

,** New definition for REGO-FUNCTION-NAME-TEST-1

;; The definition of REGO-FUNCTION-NAME-TEST-1 changes after 3 cycles
;; but the recursive local function SELF fills the fourth cycle.
(* 4 3) .1 (lambda () (setf (symbol-function 'rego-function-name-test-1) \
                            (constantly nil)))

,** End

end-of-score
#+end_example

::: regostring->function
::: regofile->lispfile
::: regofile->list
::: regostring->list
::: regolist->file
#+texinfo: @page
** Networking
*** General Stream Sockets
::: net:stream
::: net:input-stream
::: net:input-stream-p
::: net:output-stream
::: net:output-stream-p
::: net:+default-msg-flags+
::: net:*buffer-size*
::: net:*listen-backlog*
::: net:host
::: net:port
::: net:direction
::: net:protocol
::: net:protocolp
::: net:buffer-pointer
::: net:buffer-size
::: net:open
::: net:open-p
::: net:*before-close-hook*
::: net:close
::: net:read
::: net:write
::: net:foreign-read
::: net:foreign-write
::: net:broadcast
::: net:block-p
::: net:without-block
::: net:socket-fd
::: net:last-recv-fd
::: net:socket-send
::: net:connect
::: net:connected-p
::: net:connections
::: net:connections-fd
::: net:close-connections
::: net:reject
::: net:buffer-to-string
::: net:string-to-buffer
::: net:buffer-to-octets
::: net:octets-to-buffer
::: net:slip-encode
::: net:slip-decode
*** Open Sound Control
::: osc:stream
::: osc:input-stream
::: osc:input-stream-p
::: osc:output-stream
::: osc:output-stream-p
::: osc:*buffer-size*
::: osc:*max-values*
::: osc:latency
::: osc:max-values
::: osc:message-encoding
::: osc:open
::: osc:with-stream
::: osc:message-pointer
::: osc:message-length
::: osc:bundle-length
::: osc:message-time
::: osc:message
::: osc:start-message
::: osc:send
::: osc:simple-bundle
::: osc:bundle
::: osc:send-bundle
::: osc:receive
::: osc:end-of-bundle-p
::: osc:flush-bundle
::: osc:copy-packet
::: osc:address-pattern
::: osc:check-pattern
::: osc:index-values
::: osc:value
::: osc:value-pointer
::: osc:with-values
::: osc:required-values
::: osc:midi
::: osc:fix-size
#+texinfo: @page
** Serial IO
::: open-serial-port
::: serial-stream-p
::: serial-flush
** Midifile
::: midifile:stream
::: midifile:input-stream
::: midifile:input-stream-p
::: midifile:output-stream
::: midifile:output-stream-p
::: midifile:open
::: midifile:open-p
::: midifile:close
::: midifile:with-open-midifile
::: midifile:read-header
::: midifile:write-header
::: midifile:read-event

#+texinfo: @noindent
Example:

#+begin_example
(in-package :scratch)

(dsp! oscilla ((keynum fixnum) (velocity fixnum) scaler gate)
  (with-samples ((freq (tuning-cps *default-tuning* keynum))
                 (amp (* scaler velocity (sample 1/127))))
    (stereo (* (envelope (make-adsr .001 .09 .8 .7) gate 1 #'free)
               (sine freq amp)))))

(defun get-id-by-midi-note (channel keynum)
  (+ (ash channel 7) keynum 1))

(defun oscillante (status data1 data2)
  (let ((ch (logand status #xF)))
    (cond ((midi-note-on-p status)
           (oscilla data1 data2 1/10 1
                    :id (get-id-by-midi-note ch data1)))
          ((midi-note-off-p status)
           (set-control (get-id-by-midi-note ch data1) :gate 0)))))

(defun play-midifile (path)
  (with-schedule
    (with-open-midifile (mf path)
      (loop for st = (midifile:read-event mf)
            while st
            when (< st #xF0)
              do (at (* (midifile:event-seconds mf) *sample-rate*)
                     #'oscillante st
                     (midifile:message-data1 mf)
                     (midifile:message-data2 mf))))))

;; Note: all the events are scheduled if the value of the configuration
;; variable *RT-EDF-HEAP-SIZE* in ${HOME}/.incudinerc is at least:
(with-open-midifile (mf "/path/to/file.mid")
  (next-power-of-two (loop while (midifile:read-event mf) sum 1)))

(rt-start)

(play-midifile "/path/to/file.mid")

;; Stop playing before the end if necessary.
(flush-pending)
(free 0)

;; Write a sound file.
(with-logger (:level :info)
  (bounce-to-disk ("oscilla-test.wav" :channels 2 :duration 60)
    (play-midifile "/path/to/file.mid")))
#+end_example

::: midifile:write-short-event
::: midifile:write-event
::: midifile:write-tempo-track
::: midifile:message
::: midifile:tempo-message
::: midifile:string-message
::: midifile:path
::: midifile:data
::: midifile:format
::: midifile:ppqn
::: midifile:smpte
::: midifile:number-of-tracks
::: midifile:current-track
::: midifile:next-track
::: midifile:end-of-track
::: midifile:tempo
::: midifile:message-status
::: midifile:message-data1
::: midifile:message-data2
::: midifile:message-length
::: midifile:message-buffer
::: midifile:event-time
::: midifile:event-delta-time
::: midifile:event-beats
::: midifile:event-seconds
::: midifile:release-cached-buffers
#+texinfo: @page
** Soundfile
::: soundfile:stream
::: soundfile:input-stream
::: soundfile:input-stream-p
::: soundfile:output-stream
::: soundfile:output-stream-p
::: soundfile:open
::: soundfile:open-p
::: soundfile:close
::: soundfile:with-open-soundfile
::: soundfile:update-header
::: soundfile:read-header
::: soundfile:read
::: soundfile:read-next
::: soundfile:read-into-buffer
::: soundfile:foreign-read
::: soundfile:write
::: soundfile:foreign-write
::: soundfile:eof-p
::: soundfile:duration
::: soundfile:channels
::: soundfile:frames
::: soundfile:sample-rate
::: soundfile:header-type
::: soundfile:data-format
::: soundfile:metadata
::: soundfile:file-data
::: soundfile:data-location
::: soundfile:path
::: soundfile:buffer-data
::: soundfile:buffer-size
::: soundfile:buffer-value
::: soundfile:buffer-index
::: soundfile:current-frame
::: soundfile:position
::: soundfile:offset
::: soundfile:maxamp
::: soundfile:convert
::: soundfile:concatenate
::: soundfile:merge
#+texinfo: @page
** Profiling
::: incudine.util:profile
::: incudine.util:profile-node
::: incudine.util:unprofile
::: incudine.util:profile-report
::: incudine.util:profile-reset
#+texinfo: @page
** Contributed Modules
